// 6 etapes
// 1: initialiser tes mutex;
// 2: initialiser tes philo;
// 3: creer les thread (pthread_create + join)
// 4: routines (eat, sleep, think)
// 5: checker (thread)
// 6: destroy all mutex


------------------------------------------------------------------------------------------

1. Initialisation

Allouer et initialiser tab_forks (mutex pour chaque fourchette).

Allouer et remplir philos :

donner leur id

mettre meal_eaten = 0

relier left_fork et right_fork Ã  tab_forks.

Initialiser print_lock et state_lock.

------------------------------------------------------------------------------------------

ðŸ”¹ 2. CrÃ©ation des threads

Boucler sur chaque philosophe et crÃ©er un pthread_create(&philo[i].thread, NULL, routine, &philo[i]).

Routine = la vie du philosophe (eat â†’ sleep â†’ think).

------------------------------------------------------------------------------------------

ðŸ”¹ 3. Routine des philosophes

take_forks : verrouiller les mutex gauche et droite (attention Ã  lâ€™ordre pour Ã©viter deadlock).

eat : afficher log + mettre Ã  jour last_meal + incrÃ©menter meal_eaten.

release_forks : dÃ©verrouiller les deux mutex.

sleep : afficher log + usleep.

think : afficher log.

-----------------------------------------------------------------------------------------

ðŸ”¹ 4. Thread de monitoring

Lancer un thread qui surveille :

si un philosophe meurt (now - last_meal > time_to_die).

si tous ont fini (full_meals == true pour tous).

Si une condition est remplie â†’ arrÃªter la simulation (simulation_active = false).

-----------------------------------------------------------------------------------------

ðŸ”¹ 5. Gestion de la fin

pthread_join sur tous les philosophes.

DÃ©truire tous les mutex (pthread_mutex_destroy).

Free la mÃ©moire (philos, tab_forks).
